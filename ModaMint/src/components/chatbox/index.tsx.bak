import React, { useState, useRef, useEffect } from 'react';import React, { useState, useRef, useEffect } from 'react';import React, { useState, useRef, useEffect } from 'react';

import './style.css';

import { chatService } from '../../services/chat';import './style.css';import './style.css';

import { SenderType, type MessageResponse, type ChatMessage } from '../../types/chat.types';

import { useAuth } from '../../contexts/authContext';import { chatService } from '../../services/chat';import { chatService } from '../../services/chat';

import { toast } from 'react-toastify';

import { SenderType, type MessageResponse, type ChatMessage } from '../../types/chat.types';import { SenderType, type MessageResponse, type ChatMessage } from '../../types/chat.types';

type ChatMode = 'ai' | 'shop';

import { useAuth } from '../../contexts/authContext';import { useAuth } from '../../contexts/authContext';

export default function Chatbox() {

  const { user } = useAuth();import { toast } from 'react-toastify';import { toast } from 'react-toastify';

  const [messages, setMessages] = useState<ChatMessage[]>([]);

  const [input, setInput] = useState('');

  const [open, setOpen] = useState(false);

  const [maximized, setMaximized] = useState(false);type ChatMode = 'ai' | 'shop';type ChatMode = 'ai' | 'staff';

  const [chatMode, setChatMode] = useState<ChatMode>('ai');

  const [conversationId, setConversationId] = useState<number | null>(null);

  const [isLoading, setIsLoading] = useState(false);

  const [wsConnected, setWsConnected] = useState(false);export default function Chatbox() {export default function Chatbox() {

  const messagesEndRef = useRef<HTMLDivElement | null>(null);

  const { user } = useAuth();  const { user } = useAuth();

  if (!user?.id) {

    return null;  const [messages, setMessages] = useState<ChatMessage[]>([]);  const [messages, setMessages] = useState<ChatMessage[]>([]);

  }

  const [input, setInput] = useState('');  const [input, setInput] = useState('');

  useEffect(() => {

    if (open && messagesEndRef.current) {  const [open, setOpen] = useState(false);  const [open, setOpen] = useState(false);

      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });

    }  const [maximized, setMaximized] = useState(false);  const [maximized, setMaximized] = useState(false);

  }, [messages, open]);

  const [chatMode, setChatMode] = useState<ChatMode>('ai');  const [chatMode, setChatMode] = useState<ChatMode>('ai');

  useEffect(() => {

    const initializeConversation = async () => {  const [conversationId, setConversationId] = useState<number | null>(null);  const [conversationId, setConversationId] = useState<number | null>(null);

      if (open && !conversationId && user?.id) {

        try {  const [isLoading, setIsLoading] = useState(false);  const [isLoading, setIsLoading] = useState(false);

          setIsLoading(true);

          const conversation = await chatService.getConversation(user.id);  const [wsConnected, setWsConnected] = useState(false);  const [wsConnected, setWsConnected] = useState(false);

          setConversationId(conversation.id);

            const messagesEndRef = useRef<HTMLDivElement | null>(null);  const messagesEndRef = useRef<HTMLDivElement | null>(null);

          const previousMessages = await chatService.getChatHistory(conversation.id);

          const formattedMessages: ChatMessage[] = previousMessages.map(msg => ({

            id: msg.id,

            from: msg.senderType === SenderType.CUSTOMER ? 'user' :   // Guard: Don't render if no user  // Auto scroll to bottom when new messages arrive

                  msg.senderType === SenderType.AI ? 'ai' : 'staff',

            text: msg.content,  if (!user?.id) {  useEffect(() => {

            timestamp: msg.timestamp,

            senderType: msg.senderType,    return null;    if (open && messagesEndRef.current) {

          }));

          setMessages(formattedMessages);  }      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });

        } catch (error) {

          console.error('Failed to initialize conversation:', error);    }

          toast.error('Không thể khởi tạo cuộc trò chuyện');

        } finally {  // Auto scroll to bottom when new messages arrive  }, [messages, open]);

          setIsLoading(false);

        }  useEffect(() => {

      }

    };    if (open && messagesEndRef.current) {  // Initialize conversation when chatbox opens



    initializeConversation();      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });  useEffect(() => {

  }, [open, conversationId, user]);

    }    const initializeConversation = async () => {

  useEffect(() => {

    if (!conversationId) return;  }, [messages, open]);      if (open && !conversationId && user?.id) {



    const connectWS = () => {        try {

      try {

        chatService.connectWebSocket(  // Initialize conversation when chatbox opens          const conversation = await chatService.startConversation(user.id);

          chatMode,

          (messageResponse: MessageResponse) => {  useEffect(() => {          setConversationId(conversation.id);

            const newMessage: ChatMessage = {

              id: messageResponse.id,    const initializeConversation = async () => {          

              from: messageResponse.senderType === SenderType.CUSTOMER ? 'user' : 

                    messageResponse.senderType === SenderType.AI ? 'ai' : 'staff',      if (open && !conversationId && user?.id) {          // Load previous messages

              text: messageResponse.content,

              timestamp: messageResponse.timestamp,        try {          const previousMessages = await chatService.getMessages(conversation.id);

              senderType: messageResponse.senderType,

            };          setIsLoading(true);          const formattedMessages: ChatMessage[] = previousMessages.map(msg => ({

            setMessages(prev => [...prev, newMessage]);

          },          const conversation = await chatService.getConversation(user.id);            id: msg.id,

          () => {

            setWsConnected(true);          setConversationId(conversation.id);            from: msg.senderType === SenderType.CUSTOMER ? 'user' : 

            console.log(`WebSocket connected for ${chatMode} mode`);

          },                            msg.senderType === SenderType.AI ? 'ai' : 'staff',

          (error) => {

            console.error('WebSocket error:', error);          // Load previous messages            text: msg.content,

            setWsConnected(false);

            toast.error('Kết nối thất bại');          const previousMessages = await chatService.getChatHistory(conversation.id);            timestamp: msg.timestamp,

          }

        );          const formattedMessages: ChatMessage[] = previousMessages.map(msg => ({            senderType: msg.senderType,

      } catch (error) {

        console.error('Failed to connect WebSocket:', error);            id: msg.id,          }));

        setWsConnected(false);

      }            from: msg.senderType === SenderType.CUSTOMER ? 'user' :           setMessages(formattedMessages);

    };

                  msg.senderType === SenderType.AI ? 'ai' : 'staff',        } catch (error) {

    if (chatService.isConnected()) {

      chatService.disconnectWebSocket();            text: msg.content,          console.error('Failed to initialize conversation:', error);

      setWsConnected(false);

    }            timestamp: msg.timestamp,          toast.error('Không thể khởi tạo cuộc trò chuyện');

    

    connectWS();            senderType: msg.senderType,        }



    return () => {          }));      }

      if (chatService.isConnected()) {

        chatService.disconnectWebSocket();          setMessages(formattedMessages);    };

        setWsConnected(false);

      }        } catch (error) {

    };

  }, [chatMode, conversationId]);          console.error('Failed to initialize conversation:', error);    initializeConversation();



  useEffect(() => {          toast.error('Không thể khởi tạo cuộc trò chuyện');  }, [open, conversationId, user]);

    if (!open && wsConnected) {

      chatService.disconnectWebSocket();        } finally {

      setWsConnected(false);

    }          setIsLoading(false);  // Connect WebSocket when switching to staff mode

  }, [open, wsConnected]);

        }  useEffect(() => {

  const handleSend = async (e: React.FormEvent) => {

    e.preventDefault();      }    if (chatMode === 'staff' && conversationId && !wsConnected) {

    if (!input.trim() || !conversationId || isLoading || !wsConnected) return;

    };      try {

    const userMessage: ChatMessage = {

      from: 'user',        chatService.connectWebSocket(

      text: input,

      timestamp: new Date().toISOString(),    initializeConversation();          conversationId,

      senderType: SenderType.CUSTOMER,

    };    // eslint-disable-next-line react-hooks/exhaustive-deps          (messageResponse: MessageResponse) => {



    setMessages(prev => [...prev, userMessage]);  }, [open, conversationId]);            // Handle incoming message from WebSocket

    const messageContent = input;

    setInput('');            const newMessage: ChatMessage = {

    setIsLoading(true);

  // Connect WebSocket when mode changes or conversation is ready              id: messageResponse.id,

    try {

      chatService.sendMessage(messageContent, SenderType.CUSTOMER, chatMode);  useEffect(() => {              from: messageResponse.senderType === SenderType.CUSTOMER ? 'user' : 

    } catch (error) {

      console.error('Failed to send message:', error);    if (!conversationId) return;                    messageResponse.senderType === SenderType.AI ? 'ai' : 'staff',

      toast.error('Không thể gửi tin nhắn');

    } finally {              text: messageResponse.content,

      setIsLoading(false);

    }    const connectWS = () => {              timestamp: messageResponse.timestamp,

  };

      try {              senderType: messageResponse.senderType,

  const handleModeChange = (mode: ChatMode) => {

    if (mode === chatMode) return;        chatService.connectWebSocket(            };

    setChatMode(mode);

  };          chatMode,            setMessages(prev => [...prev, newMessage]);



  const handleClose = () => {          (messageResponse: MessageResponse) => {          },

    setOpen(false);

    setMaximized(false);            // Handle incoming message from WebSocket          () => {

    if (wsConnected) {

      chatService.disconnectWebSocket();            const newMessage: ChatMessage = {            setWsConnected(true);

      setWsConnected(false);

    }              id: messageResponse.id,            console.log('WebSocket connected successfully');

  };

              from: messageResponse.senderType === SenderType.CUSTOMER ? 'user' :           },

  const getMessageAvatar = (from: string) => {

    switch (from) {                    messageResponse.senderType === SenderType.AI ? 'ai' : 'staff',          (error) => {

      case 'ai': return '🤖';

      case 'staff': return '👨‍💼';              text: messageResponse.content,            console.error('WebSocket error:', error);

      case 'user': return '🙋‍♀️';

      default: return '💬';              timestamp: messageResponse.timestamp,            toast.error('Kết nối thất bại. Vui lòng thử lại.');

    }

  };              senderType: messageResponse.senderType,          }



  const getMessageLabel = (from: string) => {            };        );

    switch (from) {

      case 'ai': return 'AI Assistant';            setMessages(prev => [...prev, newMessage]);      } catch (error) {

      case 'staff': return 'Nhân viên Shop';

      case 'user': return 'Bạn';          },        console.error('Failed to connect WebSocket:', error);

      default: return '';

    }          () => {      }

  };

            setWsConnected(true);    }

  return (

    <div className={`modamint-chatbox ${open ? 'open' : ''} ${maximized ? 'maximized' : ''}`}>            console.log(`WebSocket connected for ${chatMode} mode`);

      <button className="modamint-chatbox-toggle" onClick={() => { setOpen(o => !o); if (maximized) setMaximized(false); }}>

        <span role="img" aria-label="Chat">💬</span>          },    return () => {

      </button>

      {open && (          (error) => {      if (chatMode === 'ai' && wsConnected) {

        <div className="modamint-chatbox-window" role="dialog">

          <div className="modamint-chatbox-header">            console.error('WebSocket error:', error);        chatService.disconnectWebSocket();

            <div className="modamint-chatbox-title">

              <div>Hỗ trợ khách hàng</div>            setWsConnected(false);        setWsConnected(false);

              <div className="modamint-chatbox-mode-switch">

                <button className={`mode-btn ${chatMode === 'ai' ? 'active' : ''}`} onClick={() => handleModeChange('ai')} disabled={isLoading}>            toast.error('Kết nối thất bại. Vui lòng thử lại.');      }

                  🤖 AI

                </button>          }    };

                <button className={`mode-btn ${chatMode === 'shop' ? 'active' : ''}`} onClick={() => handleModeChange('shop')} disabled={isLoading}>

                  👨‍💼 Shop        );  }, [chatMode, conversationId, wsConnected]);

                </button>

              </div>      } catch (error) {

              <div className="ws-status">

                <span className={wsConnected ? 'connected' : 'disconnected'}>        console.error('Failed to connect WebSocket:', error);  // Disconnect WebSocket when chatbox closes

                  {wsConnected ? '● Đã kết nối' : '○ Đang kết nối...'}

                </span>        setWsConnected(false);  useEffect(() => {

              </div>

            </div>      }    if (!open && wsConnected) {

            <div className="modamint-chatbox-controls">

              <button className="modamint-chatbox-control" onClick={() => setMaximized(m => !m)}>    };      chatService.disconnectWebSocket();

                {maximized ? '🗗' : '🗖'}

              </button>      setWsConnected(false);

              <button className="modamint-chatbox-control close" onClick={handleClose}>✕</button>

            </div>    // Disconnect old connection and connect new one    }

          </div>

          <div className="modamint-chatbox-messages">    if (chatService.isConnected()) {  }, [open, wsConnected]);

            {messages.length === 0 && (

              <div className="empty-state">      chatService.disconnectWebSocket();

                <p>👋 Xin chào! Chúng tôi có thể giúp gì cho bạn?</p>

                <p className="hint">{chatMode === 'ai' ? 'Hỏi AI để được hỗ trợ nhanh chóng' : 'Kết nối với nhân viên shop'}</p>      setWsConnected(false);  const handleSend = async (e: React.FormEvent) => {

              </div>

            )}    }    e.preventDefault();

            {messages.map((msg, i) => (

              <div key={msg.id || i} className={`modamint-chatbox-row ${msg.from}`}>        if (!input.trim() || !conversationId || isLoading) return;

                {(msg.from === 'ai' || msg.from === 'staff') && (

                  <div className="modamint-chatbox-avatar"><span>{getMessageAvatar(msg.from)}</span></div>    connectWS();

                )}

                <div className={`modamint-chatbox-msg ${msg.from}`}>    const userMessage: ChatMessage = {

                  <div className="message-header">

                    <span className="sender-name">{getMessageLabel(msg.from)}</span>    return () => {      from: 'user',

                    {msg.timestamp && <span className="timestamp">{new Date(msg.timestamp).toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' })}</span>}

                  </div>      if (chatService.isConnected()) {      text: input,

                  <div className="modamint-chatbox-bubble">{msg.text}</div>

                </div>        chatService.disconnectWebSocket();      timestamp: new Date().toISOString(),

                {msg.from === 'user' && (

                  <div className="modamint-chatbox-avatar user"><span>{getMessageAvatar(msg.from)}</span></div>        setWsConnected(false);      senderType: SenderType.CUSTOMER,

                )}

              </div>      }    };

            ))}

            {isLoading && (    };    setMessages(prev => [...prev, userMessage]);

              <div className="modamint-chatbox-row ai">

                <div className="modamint-chatbox-avatar"><span>{getMessageAvatar(chatMode === 'ai' ? 'ai' : 'staff')}</span></div>    // eslint-disable-next-line react-hooks/exhaustive-deps    const messageContent = input;

                <div className="modamint-chatbox-msg ai">

                  <div className="modamint-chatbox-bubble loading">  }, [chatMode, conversationId]);    setInput('');

                    <span className="dot"></span><span className="dot"></span><span className="dot"></span>

                  </div>    setIsLoading(true);

                </div>

              </div>  // Disconnect WebSocket when chatbox closes

            )}

            <div ref={messagesEndRef} />  useEffect(() => {    try {

          </div>

          <form className="modamint-chatbox-input" onSubmit={handleSend}>    if (!open && wsConnected) {      if (chatMode === 'ai') {

            <input type="text" value={input} onChange={e => setInput(e.target.value)}

              placeholder={chatMode === 'ai' ? 'Hỏi AI...' : wsConnected ? 'Nhắn tin với shop...' : 'Đang kết nối...'}      chatService.disconnectWebSocket();        // Send to AI

              disabled={isLoading || !wsConnected} autoFocus />

            <button type="submit" disabled={isLoading || !input.trim() || !wsConnected}>      setWsConnected(false);        const response = await chatService.chatWithAI(conversationId, {

              {isLoading ? '⏳' : '📤'}

            </button>    }          content: messageContent,

          </form>

        </div>    // eslint-disable-next-line react-hooks/exhaustive-deps          senderType: SenderType.CUSTOMER,

      )}

    </div>  }, [open]);        });

  );

}


  const handleSend = async (e: React.FormEvent) => {        const aiMessage: ChatMessage = {

    e.preventDefault();          id: response.id,

    if (!input.trim() || !conversationId || isLoading || !wsConnected) return;          from: 'ai',

          text: response.content,

    const userMessage: ChatMessage = {          timestamp: response.timestamp,

      from: 'user',          senderType: response.senderType,

      text: input,        };

      timestamp: new Date().toISOString(),        setMessages(prev => [...prev, aiMessage]);

      senderType: SenderType.CUSTOMER,      } else {

    };        // Send through WebSocket to staff

        if (!wsConnected) {

    setMessages(prev => [...prev, userMessage]);          toast.error('Chưa kết nối với nhân viên. Vui lòng thử lại.');

    const messageContent = input;          return;

    setInput('');        }

    setIsLoading(true);        chatService.sendMessage(conversationId, messageContent, SenderType.CUSTOMER);

        // Message will be added through WebSocket callback

    try {      }

      // Send through WebSocket for both AI and Shop    } catch (error) {

      chatService.sendMessage(      console.error('Failed to send message:', error);

        messageContent,      toast.error('Không thể gửi tin nhắn. Vui lòng thử lại.');

        SenderType.CUSTOMER,    } finally {

        chatMode      setIsLoading(false);

      );    }

      // Response will come through WebSocket callback  };

    } catch (error) {

      console.error('Failed to send message:', error);  const handleModeChange = (mode: ChatMode) => {

      toast.error('Không thể gửi tin nhắn. Vui lòng thử lại.');    if (mode === chatMode) return;

    } finally {    setChatMode(mode);

      setIsLoading(false);    

    }    if (mode === 'ai') {

  };      // Disconnect WebSocket when switching to AI

      if (wsConnected) {

  const handleModeChange = (mode: ChatMode) => {        chatService.disconnectWebSocket();

    if (mode === chatMode) return;        setWsConnected(false);

    setChatMode(mode);      }

  };    }

  };

  const handleClose = () => {

    setOpen(false);  const handleClose = () => {

    setMaximized(false);    setOpen(false);

    if (wsConnected) {    setMaximized(false);

      chatService.disconnectWebSocket();    if (wsConnected) {

      setWsConnected(false);      chatService.disconnectWebSocket();

    }      setWsConnected(false);

  };    }

  };

  const getMessageAvatar = (from: string) => {

    switch (from) {  const getMessageAvatar = (from: string) => {

      case 'ai':    switch (from) {

        return '🤖';      case 'ai':

      case 'staff':        return '🤖';

        return '👨‍💼';      case 'staff':

      case 'user':        return '👨‍💼';

        return '🙋‍♀️';      case 'user':

      default:        return '🙋‍♀️';

        return '💬';      default:

    }        return '💬';

  };    }

  };

  const getMessageLabel = (from: string) => {

    switch (from) {  const getMessageLabel = (from: string) => {

      case 'ai':    switch (from) {

        return 'AI Assistant';      case 'ai':

      case 'staff':        return 'AI Assistant';

        return 'Nhân viên Shop';      case 'staff':

      case 'user':        return 'Nhân viên';

        return 'Bạn';      case 'user':

      default:        return 'Bạn';

        return '';      default:

    }        return '';

  };    }

  };

  return (

    <div className={`modamint-chatbox ${open ? 'open' : ''} ${maximized ? 'maximized' : ''}`}>

      <button className="modamint-chatbox-toggle" onClick={() => { setOpen(o => !o); if (maximized) setMaximized(false); }}>  return (

        <span role="img" aria-label="Chat">💬</span>    <div className={`modamint-chatbox ${open ? 'open' : ''} ${maximized ? 'maximized' : ''}`}>

      </button>      <button className="modamint-chatbox-toggle" onClick={() => { setOpen(o => !o); if (maximized) setMaximized(false); }}>

      {open && (        <span role="img" aria-label="Chat">💬</span>

        <div className="modamint-chatbox-window" role="dialog" aria-label="Chat support">      </button>

          <div className="modamint-chatbox-header">      {open && (

            <div className="modamint-chatbox-title">        <div className="modamint-chatbox-window" role="dialog" aria-label="Chat support">

              <div>Hỗ trợ khách hàng</div>          <div className="modamint-chatbox-header">

              <div className="modamint-chatbox-mode-switch">            <div className="modamint-chatbox-title">

                <button              <div>Hỗ trợ khách hàng</div>

                  className={`mode-btn ${chatMode === 'ai' ? 'active' : ''}`}              <div className="modamint-chatbox-mode-switch">

                  onClick={() => handleModeChange('ai')}                <button

                  disabled={isLoading}                  className={`mode-btn ${chatMode === 'ai' ? 'active' : ''}`}

                >                  onClick={() => handleModeChange('ai')}

                  🤖 AI                  disabled={isLoading}

                </button>                >

                <button                  🤖 AI

                  className={`mode-btn ${chatMode === 'shop' ? 'active' : ''}`}                </button>

                  onClick={() => handleModeChange('shop')}                <button

                  disabled={isLoading}                  className={`mode-btn ${chatMode === 'staff' ? 'active' : ''}`}

                >                  onClick={() => handleModeChange('staff')}

                  👨‍💼 Shop                  disabled={isLoading}

                </button>                >

              </div>                  👨‍💼 Nhân viên

              <div className="ws-status">                </button>

                <span className={wsConnected ? 'connected' : 'disconnected'}>              </div>

                  {wsConnected ? '● Đã kết nối' : '○ Đang kết nối...'}              {chatMode === 'staff' && (

                </span>                <div className="ws-status">

              </div>                  <span className={wsConnected ? 'connected' : 'disconnected'}>

            </div>                    {wsConnected ? '● Đã kết nối' : '○ Đang kết nối...'}

            <div className="modamint-chatbox-controls">                  </span>

              <button                </div>

                className="modamint-chatbox-control"              )}

                title={maximized ? 'Thu nhỏ' : 'Mở rộng'}            </div>

                aria-label={maximized ? 'Restore' : 'Maximize'}            <div className="modamint-chatbox-controls">

                onClick={() => setMaximized(m => !m)}              <button

              >                className="modamint-chatbox-control"

                {maximized ? '🗗' : '🗖'}                title={maximized ? 'Thu nhỏ' : 'Mở rộng'}

              </button>                aria-label={maximized ? 'Restore' : 'Maximize'}

              <button                onClick={() => setMaximized(m => !m)}

                className="modamint-chatbox-control close"              >

                title="Đóng"                {maximized ? '🗗' : '🗖'}

                aria-label="Close"              </button>

                onClick={handleClose}              <button

              >                className="modamint-chatbox-control close"

                ✕                title="Đóng"

              </button>                aria-label="Close"

            </div>                onClick={handleClose}

          </div>              >

          <div className="modamint-chatbox-messages">                ✕

            {messages.length === 0 && (              </button>

              <div className="empty-state">            </div>

                <p>👋 Xin chào! Chúng tôi có thể giúp gì cho bạn?</p>          </div>

                <p className="hint">          <div className="modamint-chatbox-messages">

                  {chatMode === 'ai'             {messages.length === 0 && (

                    ? 'Hỏi AI để được hỗ trợ nhanh chóng'               <div className="empty-state">

                    : 'Kết nối với nhân viên shop để được tư vấn trực tiếp'}                <p>👋 Xin chào! Chúng tôi có thể giúp gì cho bạn?</p>

                </p>                <p className="hint">

              </div>                  {chatMode === 'ai' 

            )}                    ? 'Hỏi AI để được hỗ trợ nhanh chóng' 

            {messages.map((msg, i) => (                    : 'Kết nối với nhân viên để được tư vấn trực tiếp'}

              <div key={msg.id || i} className={`modamint-chatbox-row ${msg.from}`}>                </p>

                {(msg.from === 'ai' || msg.from === 'staff') && (              </div>

                  <div className="modamint-chatbox-avatar" aria-hidden>            )}

                    <span>{getMessageAvatar(msg.from)}</span>            {messages.map((msg, i) => (

                  </div>              <div key={msg.id || i} className={`modamint-chatbox-row ${msg.from}`}>

                )}                {(msg.from === 'ai' || msg.from === 'staff') && (

                  <div className="modamint-chatbox-avatar" aria-hidden>

                <div className={`modamint-chatbox-msg ${msg.from}`}>                    <span>{getMessageAvatar(msg.from)}</span>

                  <div className="message-header">                  </div>

                    <span className="sender-name">{getMessageLabel(msg.from)}</span>                )}

                    {msg.timestamp && (

                      <span className="timestamp">                <div className={`modamint-chatbox-msg ${msg.from}`}>

                        {new Date(msg.timestamp).toLocaleTimeString('vi-VN', {                  <div className="message-header">

                          hour: '2-digit',                    <span className="sender-name">{getMessageLabel(msg.from)}</span>

                          minute: '2-digit',                    {msg.timestamp && (

                        })}                      <span className="timestamp">

                      </span>                        {new Date(msg.timestamp).toLocaleTimeString('vi-VN', {

                    )}                          hour: '2-digit',

                  </div>                          minute: '2-digit',

                  <div className="modamint-chatbox-bubble">{msg.text}</div>                        })}

                </div>                      </span>

                    )}

                {msg.from === 'user' && (                  </div>

                  <div className="modamint-chatbox-avatar user" aria-hidden>                  <div className="modamint-chatbox-bubble">{msg.text}</div>

                    <span>{getMessageAvatar(msg.from)}</span>                </div>

                  </div>

                )}                {msg.from === 'user' && (

              </div>                  <div className="modamint-chatbox-avatar user" aria-hidden>

            ))}                    <span>{getMessageAvatar(msg.from)}</span>

            {isLoading && (                  </div>

              <div className="modamint-chatbox-row ai">                )}

                <div className="modamint-chatbox-avatar" aria-hidden>              </div>

                  <span>{getMessageAvatar(chatMode === 'ai' ? 'ai' : 'staff')}</span>            ))}

                </div>            {isLoading && (

                <div className="modamint-chatbox-msg ai">              <div className="modamint-chatbox-row ai">

                  <div className="modamint-chatbox-bubble loading">                <div className="modamint-chatbox-avatar" aria-hidden>

                    <span className="dot"></span>                  <span>{getMessageAvatar(chatMode === 'ai' ? 'ai' : 'staff')}</span>

                    <span className="dot"></span>                </div>

                    <span className="dot"></span>                <div className="modamint-chatbox-msg ai">

                  </div>                  <div className="modamint-chatbox-bubble loading">

                </div>                    <span className="dot"></span>

              </div>                    <span className="dot"></span>

            )}                    <span className="dot"></span>

            <div ref={messagesEndRef} />                  </div>

          </div>                </div>

          <form className="modamint-chatbox-input" onSubmit={handleSend}>              </div>

            <input            )}

              type="text"            <div ref={messagesEndRef} />

              value={input}          </div>

              onChange={e => setInput(e.target.value)}          <form className="modamint-chatbox-input" onSubmit={handleSend}>

              placeholder={            <input

                chatMode === 'ai'               type="text"

                  ? 'Hỏi AI...'               value={input}

                  : wsConnected               onChange={e => setInput(e.target.value)}

                    ? 'Nhắn tin với nhân viên shop...'              placeholder={

                    : 'Đang kết nối...'                chatMode === 'ai' 

              }                  ? 'Hỏi AI...' 

              disabled={isLoading || !wsConnected}                  : wsConnected 

              autoFocus                    ? 'Nhắn tin với nhân viên...'

            />                    : 'Đang kết nối...'

            <button               }

              type="submit"               disabled={isLoading || (chatMode === 'staff' && !wsConnected)}

              disabled={isLoading || !input.trim() || !wsConnected}              autoFocus

            >            />

              {isLoading ? '⏳' : '📤'}            <button 

            </button>              type="submit" 

          </form>              disabled={isLoading || !input.trim() || (chatMode === 'staff' && !wsConnected)}

        </div>            >

      )}              {isLoading ? '⏳' : '📤'}

    </div>            </button>

  );          </form>

}        </div>

      )}
    </div>
  );
}
